Actaria Engine virtual machine works according to the following algorithm:

while(!endOfGame) {
  while(!endOfDialog) {
    answerChoice();
    handlePlayerReaction(); // here the dialog context is updated
  }
  handleDialogVerdict(); // here the scene and game context are updated
}

==================================================

Requirements for the Oriented Story Graph (OSG):

* Connectivity (completeness of the game)

* Existence of leaves (game endings)

* Reachability of a leaf from any node (finiteness of the game)

All entities in Actaria have interfaces for both text and binary serialization.
This is what an entity descriptor looks like:

<entity flag><offset><data>

The fields "entity flag" and "offset" are mandatory.
Here, the "entity flag" is a special hash generated by the compiler through the built-in typeid(T).hash_code() [-> size_t]. It is used for unambiguous identification of the structure being read.
"Offset" is the length of the structure excluding the mandatory fields.
"Data" is the serialized object.

==================================================

Virtual machine bytecode format:

<version><number of entities>|entities|<root scene id>

"Version" and "number of entities" are mandatory fixed-length fields.
"Entities" are the sequential representations of each game entity (trigger, scene, etc.).
"Root scene id" is the unique identifier of the entity that defines the beginning of the game.

All mandatory fields have a length of 2–4 bytes.
